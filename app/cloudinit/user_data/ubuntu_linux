#cloud-config
# Package installation
{{ if and (.IsHosted) (eq .Platform.Arch "amd64") }}
packages:
  - wget
{{ else }}
apt:
  sources:
    docker.list:
      source: deb [arch={{ .Platform.Arch }}] https://download.docker.com/linux/ubuntu $RELEASE stable
      keyid: 9DC858229FC7DD38854AE2D88D81803C0EBFCD88
packages:
  - wget
  - docker-ce
{{ end }}
{{ if .EnableC4D }}
# Early boot commands to detect NVMe disk
bootcmd:
  - mkdir -p /var/log
  - touch /var/log/nvme-setup.log
  - echo "Starting NVME disk detection at $(date)" >> /var/log/nvme-setup.log
  - lsblk -d >> /var/log/nvme-setup.log 2>&1
  - echo "Looking for any NVME disk (largest) excluding root..." >> /var/log/nvme-setup.log
  - |
    set -e
    ROOT_SRC=$(findmnt -no SOURCE / || true)
    ROOT_BASE=""
    if [ -n "$ROOT_SRC" ]; then
      # Try to get parent disk name; fallback to stripping partition suffix
      ROOT_BASE=$(lsblk -no pkname "$ROOT_SRC" 2>/dev/null || true)
      if [ -z "$ROOT_BASE" ]; then
        ROOT_BASE=$(basename "$ROOT_SRC" | sed 's/[0-9]*$//')
      fi
    fi
    echo "Root source: $ROOT_SRC, root base: $ROOT_BASE" >> /var/log/nvme-setup.log
    # Pick the largest non-root NVMe disk
    NVME_DEV=$(lsblk -bdno NAME,TYPE,SIZE | awk -v rb="$ROOT_BASE" '$1 ~ /^nvme/ && $2=="disk" && $1 != rb {print $1, $3}' | sort -k2,2n | tail -1 | awk '{print $1}')
    if [ -z "$NVME_DEV" ]; then
      # Fallback to first non-root NVMe if size-based selection fails
      NVME_DEV=$(lsblk -dno NAME | awk -v rb="$ROOT_BASE" '/^nvme/ && $1 != rb {print $1; exit}')
    fi
    if [ -n "$NVME_DEV" ]; then
      echo "/dev/$NVME_DEV" > /etc/nvme_device_path
      echo "Selected NVMe disk: /dev/$NVME_DEV" >> /var/log/nvme-setup.log
      ls -la /dev/$NVME_DEV >> /var/log/nvme-setup.log 2>&1
    else
      echo "No suitable NVME disk found (excluding root)" >> /var/log/nvme-setup.log
      echo "Available disks:" >> /var/log/nvme-setup.log
      lsblk >> /var/log/nvme-setup.log 2>&1
    fi
{{ else }}
# NVME setup is disabled
bootcmd:
  - mkdir -p /var/log
  - touch /var/log/nvme-setup.log
  - echo "NVME setup is disabled. Skipping NVME disk detection." >> /var/log/nvme-setup.log
{{ end }}
# Certificate files
write_files:
- path: {{ .CaCertPath }}
  permissions: '0600'
  encoding: b64
  content: {{ .CACert | base64 }}
- path: {{ .CertPath }}
  permissions: '0600'
  encoding: b64
  content: {{ .TLSCert | base64 }}
- path: {{ .KeyPath }}
  permissions: '0600'
  encoding: b64
  content: {{ .TLSKey | base64 }}
# Main runtime commands
runcmd:
  # Enable command tracing
  - set -x
  
  # Configure DNS if needed
  {{ if .ShouldUseGoogleDNS }}
  - echo "DNS=8.8.8.8 8.8.4.4\nFallbackDNS=1.1.1.1 1.0.0.1\nDomains=~." | sudo tee -a /etc/systemd/resolved.conf
  - systemctl restart systemd-resolved
  {{ end }}
  
  # Open healthcheck port
  - ufw allow 9079
  
  {{ if .EnableC4D }}
  # NVMe disk setup
  - |
    cat > /tmp/nvme-setup.sh <<'EOS'
    #!/usr/bin/env bash
    set -euo pipefail

    LOGFILE="/var/log/nvme-setup.log"
    MOUNT_POINT="/mnt/ephemeral"

    mkdir -p /var/log
    touch "$LOGFILE"
    # Do not overwrite if already set by bootcmd
    [ -f /var/log/cloud-init-start.ts ] || date -u +%s > /var/log/cloud-init-start.ts

    log() {
      echo "[$(date '+%Y-%m-%d %H:%M:%S')] $@" | tee -a "$LOGFILE"
    }

    step_start() {
      STEP_NAME="$1"
      STEP_START=$(date +%s)
      log ">>> Starting: $STEP_NAME"
    }

    step_end() {
      STEP_END=$(date +%s)
      DURATION=$((STEP_END - STEP_START))
      log "<<< Finished: $STEP_NAME (Duration: ${DURATION}s)"
    }

    ### Step 1: Detect NVMe disk
    step_start "Disk detection"
    ROOT_SRC=$(findmnt -no SOURCE / || true)
    ROOT_BASE=""
    if [ -n "$ROOT_SRC" ]; then
      ROOT_BASE=$(lsblk -no pkname "$ROOT_SRC" 2>/dev/null || true)
      if [ -z "$ROOT_BASE" ]; then
        ROOT_BASE=$(basename "$ROOT_SRC" | sed 's/[0-9]*$//')
      fi
    fi
    log "Root source: $ROOT_SRC, root base: $ROOT_BASE"

    NVME_DEV=$(lsblk -bdno NAME,TYPE,SIZE | awk -v rb="$ROOT_BASE" '$1 ~ /^nvme/ && $2=="disk" && $1 != rb {print $1, $3}' | sort -k2,2n | tail -1 | awk '{print $1}')
    if [ -z "$NVME_DEV" ]; then
      NVME_DEV=$(lsblk -dno NAME | awk -v rb="$ROOT_BASE" '/^nvme/ && $1 != rb {print $1; exit}')
    fi

    if [ -n "${NVME_DEV:-}" ]; then
      DEV_PATH="/dev/$NVME_DEV"
      echo "$DEV_PATH" > /etc/nvme_device_path
      log "Selected NVMe disk: $DEV_PATH"
    else
      log "No suitable NVME disk found (excluding root)"
      exit 1
    fi
    step_end "Disk detection"

    ### Step 2: Format disk (always fresh)
    step_start "Formatting disk"
    mkfs.ext4 -F "$DEV_PATH" | tee -a "$LOGFILE"
    step_end "Formatting disk"

    ### Step 3: Mount disk
    step_start "Mounting disk"
    mkdir -p "$MOUNT_POINT"
    mount "$DEV_PATH" "$MOUNT_POINT"

    # Get UUID for fstab
    UUID=$(blkid -s UUID -o value "$DEV_PATH")
    if ! grep -q "$UUID" /etc/fstab; then
      echo "UUID=$UUID  $MOUNT_POINT  ext4  defaults,nofail  0 2" >> /etc/fstab
      log "Added $MOUNT_POINT mount to /etc/fstab (UUID=$UUID)"
    fi
    step_end "Mounting disk"

    ### Step 4: Bind mounts for critical directories
    for dir in /tmp /harness; do
      step_start "Bind-mounting $dir"

      target="$MOUNT_POINT/$(basename "$dir")"
      [ ! -d "$dir" ] && { log "Creating $dir"; mkdir -p "$dir"; chmod 755 "$dir"; }
      mkdir -p "$target"

      if [ "$(ls -A "$dir" 2>/dev/null)" ]; then
        log "Copying content from $dir to $target..."
        cp -a "$dir/"* "$target/" 2>/dev/null || log "Warning: Some files could not be copied"
      else
        log "$dir is empty, nothing to copy"
      fi

      umount "$dir" 2>/dev/null || true
      mount --bind "$target" "$dir" || log "Failed to bind mount $dir"

      # Ensure persistence
      if ! grep -qE "[[:space:]]$dir[[:space:]]" /etc/fstab; then
        echo "$target  $dir  none  bind  0 0" >> /etc/fstab
        log "Added bind mount for $dir -> $target in /etc/fstab"
      fi

      step_end "Bind-mounting $dir"
    done

    ### Step 5: Verify mounts
    step_start "Verifying mounts"
    mount | grep -E "$UUID|$MOUNT_POINT|/tmp|/var/lib/docker|/home|/harness" | tee -a "$LOGFILE" || true
    df -h | grep -E "$MOUNT_POINT|/tmp|/var/lib/docker|/home|/harness" | tee -a "$LOGFILE" || true
    step_end "Verifying mounts"

    log "Setup complete. All mounts will persist across reboot."
    EOS
    chmod +x /tmp/nvme-setup.sh
    /tmp/nvme-setup.sh
  {{ else }}
  # NVME setup is disabled
  - |
    # Define logging function
    log_echo() {
      echo "[$(date '+%Y-%m-%d %H:%M:%S')] $@" | tee -a /var/log/nvme-setup.log
    }
    log_echo "NVME setup is disabled in configuration. Skipping NVME disk setup."
  {{ end }}
  
  # Download and install lite-engine
  - |
    (/usr/bin/wget --retry-connrefused --retry-on-host-error --retry-on-http-error=503,404,429 --tries=3 --waitretry=3 "{{ .LiteEnginePath }}/lite-engine-{{ .Platform.OS }}-{{ .Platform.Arch }}" -O /usr/bin/lite-engine && echo "Successfully downloaded lite engine binary from primary URL.") || \
    (echo "Primary URL failed for lite-engine. Trying fallback URL..." && /usr/bin/wget --retry-connrefused --retry-on-host-error --retry-on-http-error=503,404,429 --tries=10 --waitretry=10 "{{ .LiteEngineFallbackPath }}/lite-engine-{{ .Platform.OS }}-{{ .Platform.Arch }}" -O /usr/bin/lite-engine && echo "Successfully downloaded lite engine binary from fallback URL.")
  - chmod 777 /usr/bin/lite-engine
  
  # Download and install split_tests if needed
  {{ if .HarnessTestBinaryURI }}
  - wget -nv "{{ .HarnessTestBinaryURI }}/{{ .Platform.Arch }}/{{ .Platform.OS }}/bin/split_tests-{{ .Platform.OS }}_{{ .Platform.Arch }}" -O /usr/bin/split_tests
  - chmod 777 /usr/bin/split_tests
  {{ end }}
  
  # Download and install plugin if needed
  {{ if .PluginBinaryURI }}
  - |
    (wget --retry-connrefused --retry-on-host-error --retry-on-http-error=503,404,429 --tries=3 --waitretry=3 {{ .PluginBinaryURI }}/plugin-{{ .Platform.OS }}-{{ .Platform.Arch }} -O /usr/bin/plugin && echo "Successfully downloaded plugin binary from primary URL.") || \
    (echo "Primary URL failed for plugin. Trying fallback URL..." && /usr/bin/wget --retry-connrefused --retry-on-host-error --retry-on-http-error=503,404,429 --tries=10 --waitretry=10 {{ .PluginBinaryFallbackURI }}/plugin-{{ .Platform.OS }}-{{ .Platform.Arch }} -O /usr/bin/plugin && echo "Successfully downloaded plugin binary from fallback URL.")
  - chmod 777 /usr/bin/plugin
  {{ end }}
  
  # Download and install auto-injection if needed
  {{ if .AutoInjectionBinaryURI }}
  - |
    mkdir -p /tmp/harness/bin
    wget --retry-connrefused --retry-on-host-error --retry-on-http-error=503,404,429 --tries=10 --waitretry=10 -nv "{{ .AutoInjectionBinaryURI }}/{{ .Platform.OS }}/{{ .Platform.Arch }}/auto-injection" -O /usr/bin/auto-injection || \
    wget --retry-connrefused --tries=10 --waitretry=10 -nv "{{ .AutoInjectionBinaryURI }}/{{ .Platform.OS }}/{{ .Platform.Arch }}/auto-injection" -O /usr/bin/auto-injection
  - chmod 777 /usr/bin/auto-injection
  - |
    cp /usr/bin/auto-injection /tmp/harness/bin/auto-injection
  - chmod 777 /tmp/harness/bin/auto-injection
  {{ end }}
  
  # Download and install envman for amd64 architecture
  {{ if eq .Platform.Arch "amd64" }}
  - |
    (curl -fL https://github.com/bitrise-io/envman/releases/download/2.4.2/envman-Linux-x86_64 > /usr/bin/envman && echo "Successfully downloaded envman binary from primary URL.") || \
    (echo "Primary URL failed for envman. Trying fallback URL..." && curl -fL https://app.harness.io/storage/harness-download/harness-ti/harness-envman/2.4.2/envman-Linux-x86_64 > /usr/bin/envman && echo "Successfully downloaded envman binary from fallback URL.")
  - chmod 777 /usr/bin/envman
  {{ end }}
  
  # Setup environment and start lite-engine
  - touch /root/.env
  - '[ -f "/etc/environment" ] && cp "/etc/environment" /root/.env'
  - echo "CLOUD_DRIVER={{ .DriverName }}" >> /root/.env
  - /usr/bin/lite-engine server --env-file /root/.env > /var/log/lite-engine.log 2>&1 &
  
  # Setup tmate if enabled
  {{ if .Tmate.Enabled }}
  - mkdir /addon
  {{ if eq .Platform.Arch "amd64" }}
  - |
    (wget -nv https://github.com/harness/tmate/releases/download/1.0/tmate-1.0-static-linux-amd64.tar.xz -O /addon/tmate.xz && echo "Successfully downloaded tmate binary from primary URL.") || \
    (echo "Primary URL failed for tmate. Trying fallback URL..." && wget -nv https://app.harness.io/storage/harness-download/harness-ti/harness-tmate/1.0/tmate-1.0-static-linux-amd64.tar.xz -O /addon/tmate.xz && echo "Successfully downloaded tmate binary from fallback URL.")
  - tar -xf /addon/tmate.xz -C /addon/
  - chmod 777 /addon/tmate-1.0-static-linux-amd64/tmate
  - mv /addon/tmate-1.0-static-linux-amd64/tmate /addon/tmate
  - rm -rf /addon/tmate-1.0-static-linux-amd64/
  {{ else if eq .Platform.Arch "arm64" }}
  - |
    (wget -nv https://github.com/harness/tmate/releases/download/1.0/tmate-1.0-static-linux-arm64v8.tar.xz -O /addon/tmate.xz && echo "Successfully downloaded tmate binary from primary URL.") || \
    (echo "Primary URL failed for tmate. Trying fallback URL..." && wget -nv https://app.harness.io/storage/harness-download/harness-ti/harness-tmate/1.0/tmate-1.0-static-linux-arm64v8.tar.xz -O /addon/tmate.xz && echo "Successfully downloaded tmate binary from fallback URL.")
  - tar -xf /addon/tmate.xz -C /addon/
  - chmod 777 /addon/tmate-1.0-static-linux-arm64v8/tmate
  - mv /addon/tmate-1.0-static-linux-arm64v8/tmate /addon/tmate
  - rm -rf /addon/tmate-1.0-static-linux-arm64v8/
  {{ end }}
  - rm -rf /addon/tmate.xz
  {{ end }}